## 一、描述UI

1、使用React，你不用直接从代码层面修改UI，例如 不用编写“显式成功消息”这种命令；相反，只需要描述组件在不同状态（‘初始化状态’，‘输入状态’，‘成功状态’）下希望展示的UI，然后根据用户输入触发状态更改。

2、在组件间共享状态，有时候希望两个组件的状态始终同时更改，要实现这一点，可以将相关状态从这两个组件上移除，并把这些状态移到最近的父级组件，然后通过props将状态传递给这两个组件，这被称为“状态提升”。

3、在React中，渲染逻辑和标签共同存在于一个地方--组件。每个react组件都是一个JavaScript函数，它会返回一些标签，react会将这些标签渲染到浏览器上。

JSX规则：只能返回一个根元素，原因是：JSX虽然看起来很像HTML，但在底层其实被转化为了JavaScript对象，你不能在一个函数中返回多个对象，除非用一个数组把它们包装起来。所以多个JSX标签必须要用一个父元素或Fragment来包裹。

在JSX的大括号内：引用变量、调用函数、使用js对象。

React中，每个父组件通过props给子组件传值，可以是对象、数组或函数。

快捷表达式：```（1）在 JSX 中，{cond ? <A /> : <B />} 表示 “当 cond 为真值时, 渲染 <A />，否则 <B />”。 （2）在 JSX 中，{cond && <A />} 表示 “当 cond 为真值时, 渲染 <A />，否则不进行渲染”。```

React中的key值：key值在兄弟节点之间必须是唯一的（不要求全局唯一）；key值不能改变，否则失去了意义，千万不用动态地生成key。

**React 假设你编写的所有组件都是纯函数。**

React中一个组件必须是纯粹的：1、只负责自己的任务；2、输入相同则输出相同（给定相同的输入，组件应该总是返回相同的JSX）。渲染可能随时发生，因此组件不应依赖于彼此的渲染顺序。通过 “设置” state 来更新界面，而不要改变预先存在的对象。

React如何看待组件结构，将UI视为树；渲染树：组件的一个主要特性是能够由其他组件组合而成。在嵌套组件中没有父组件和子组件的概念，每个父组件可能是另一个组件的子组件。在条件渲染中，父组件可以根据传递的数据渲染不同的子组件。

渲染树表示单次渲染中React组件之间的嵌套关系；渲染树有助于识别顶级组件和叶子组件，顶级组件会影响其下所有组件的渲染性能，而叶子组件通常会频繁重新渲染，识别它们有助于调试渲染性能问题。

依赖树表示React应用程序中的模块依赖关系。

构建工具（bundler）使用依赖树来捆绑必要的代码，以部署应用程序。

## 二、添加交互

**1、响应事件**

你可以使用useState Hook为组件添加状态，内置参数有 初始值和设置函数；渲染和提交：除按法渲染-> 渲染组件-> 提交到DOM。

state如同一张快照，设置它并不改变你已有的状态变量，而是触发一次重新渲染；把一系列state更新加入队列；例如：你可以通过在设置状态时传递一个 更新器函数 来解决这个问题。注意用 setScore(s => s + 1) 替换 setScore(score + 1) 是如何修复“+3”按钮的。

更新state中的状态：不应该直接改变你在React状态中持有的对象和数组，而是需要创建一个新的对象，然后用这个副本来更新状态；

更新state中的数组：应将数组视为只读，创建一个新的数组，然后用新数组来更新状态。

你可以通过 将函数作为prop传递给元素如<button>来处理事件；必须传递事件处理函数，而非函数调用！ onClick={handleClick} ，不是 onClick={handleClick()}。

事件会向上传播，通过事件的第一个参数调用`e.stopPropagation()`来阻止；事件可能具有浏览器默认行为，使用`e.preventDefault()`来阻止这种情况。

**2、组件的记忆**

State是隔离且私有的，State是屏幕上组件实例内部的状态；换句话说，如果你渲染同一个组件两次，每个副本都会有完全隔离的state!改变其中一个不会影响另一个。

**3、渲染和提交**

有两种情况下重新渲染：（1）组件的初次渲染，（2）组件的或其祖先之一的状态发生了变化；

“渲染中”即react在调用你的组件；渲染必须始终是一次[纯计算]；

在初次渲染时，react会调用根组件；对于后续的渲染，react会调用内部状态更新触发了渲染的函数组件；

在一个react应用中，一次屏幕更新都会发送3个步骤：触发 -> 渲染 ->提交；

**4、state如同一张快照**

渲染会及时生成一张快照，“正在渲染”意味着react正在调用你的组件---一个函数；你从该函数返回的JSX就像是在某个时间点上UI的快照，它的props、事件处理函数和内部变量都是 根据当前渲染时的state被计算出来的；

当react重新渲染一个组件时，（1）react会再次调用你的函数 -> 函数会返回新的JSX快照 -> react会更新界面以匹配返回的快照。

总结：设置state请求一次新的渲染；react将state存储在组件之外，就像在架子上一样；当你调用useState时，react会为你提供该次渲染的一张state快照；每个渲染始终看到的是React提供给这个渲染的state快照。

**5、把一系列state更新加入队列**

设置组件state会把一次重新渲染加入队列，React会对state更新进行批处理；React会等到事件处理函数中的所有代码都运行完毕再处理你的state更新；这就是重新渲染只发生在所有这些setState调用之后的原因。 这让你可以更新多个state变量---甚至来自多个组件的state变量---而不会触发太多的重新渲染；只有在你的事件处理函数以及其中的代码执行完成之后，UI才会更新，这种特性就是批处理；react不会跨多个 需要刻意触发的事件（如点击）进行批处理---每次点击都是单独处理的；

总结：（1）设置state不会更改现有渲染中的变量，但会请求一次新的渲染；（2）React会在事件处理函数执行完成之后处理state更新，这被称为“批处理”；（3）要在一个事件中多次更新某个state，你可以使用setState(c=>c+1)更新函数。

**6、更新state中的对象**

state中可以保存任何类型的JavaScript值，包括对象；但是你不应该直接修改state中的对象，而是需要创建一个新的对象，然后将state更新为此对象；

将state视为只读的：应该把所有存放在state中的JavaScript对象视为只读的；不要直接修改一个对象，而要为它创建一个新版本，并通过设置state为这个新版本 来触发重新渲染；你可以使用这样的 {...obj, something: 'newValue'} 对象展开语法来创建对象的拷贝。

**7、更新state中的数组**

当你想要更新存储在state中的数组时，你需要创建一个新的数组，并使用新数组设置state；（1）向数组中添加元素：你应该创建一个新数组其包含了原始数组的所有元素以及一个在末尾的新元素，最简单的是使用[...]数组展开语法，（2）向数组中删除元素：最简单的方法是将它过滤出去、可以通过filter实现；

总结：你可以使用 `[...arr, newItem]` 这样的数组展开语法来向数组中添加元素; 你可以使用 filter() 和 map() 来创建一个经过过滤或者变换的数组。你可以使用 Immer 来保持代码简洁。

## 状态管理

1、用state响应输入；React控制UI的方式是声明式的，你不必直接控制UI的各个部分，只需要声明组件不同的状态，并根据用户的输入在它们之间切换；声明式UI与命令式UI的比较（告诉计算机如何去更新UI的编程成为命令式编程； 在React中，你不必直接去操作UI、不必直接启用、关闭、显示、隐藏组件，你只需要声明你想要显示的内容，React会通过计算得出该如何去更新UI）；

声明式地考虑UI：（1）定位你的组件中不同的视图状态，（2）确定是什么触发了这些state改变，（3）使用useState表示内存中的state，（4）删除不必要的state，（5）连接事件处理函数去设置state；






