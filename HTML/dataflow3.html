<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Data Flow Editor â€” HTML+CSS+JS(Canvas)</title>
    <style>
        :root {
            --bg: #0f1226;
            --panel: #181b36;
            --muted: #9aa3b2;
            --primary: #7c5cff;
            --primary-2: #4fd1c5;
            --danger: #ff5d6c;
            --border: #2a2f4a;
            --text: #ecf0ff;
            --text-2: #d6daf0;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font: 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial
        }

        .app {
            display: grid;
            grid-template-columns: 1fr 340px;
            gap: 12px;
            height: 100%;
            padding: 12px;
            box-sizing: border-box
        }

        .canvas-wrap {
            position: relative;
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            background: radial-gradient(1000px 600px at 20% 10%, #1a1f46 0%, #121531 60%, #0f1226 100%);
        }

        .toolbar {
            position: absolute;
            left: 12px;
            top: 12px;
            display: flex;
            gap: 8px;
            padding: 8px;
            background: rgba(24, 27, 54, .7);
            border: 1px solid var(--border);
            backdrop-filter: blur(6px);
            border-radius: 10px;
        }

        .toolbar .btn {
            background: #232750;
            border: 1px solid var(--border);
            color: var(--text-2);
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer;
            user-select: none
        }

        .toolbar .btn.primary {
            background: var(--primary);
            color: white;
            border-color: transparent
        }

        .toolbar .btn.danger {
            background: #3a1f2a;
            border-color: #5b2230;
            color: #ffd9de
        }

        .toolbar .btn:disabled {
            opacity: .55;
            cursor: not-allowed
        }

        .hint {
            position: absolute;
            right: 12px;
            top: 12px;
            font-size: 12px;
            color: var(--muted);
            background: rgba(24, 27, 54, .7);
            border: 1px solid var(--border);
            padding: 8px 10px;
            border-radius: 8px;
            backdrop-filter: blur(6px);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%
        }

        .panel {
            border: 1px solid var(--border);
            border-radius: 12px;
            background: var(--panel);
            display: flex;
            flex-direction: column;
            min-height: 0
        }

        .panel h3 {
            margin: 12px 12px 6px 12px;
            font-size: 14px;
            color: var(--text-2);
            font-weight: 600
        }

        .panel .section {
            padding: 8px 12px;
            border-top: 1px solid var(--border)
        }

        .panel textarea {
            width: 100%;
            min-height: 120px;
            background: #0f1226;
            color: var(--text-2);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px;
            box-sizing: border-box
        }

        .panel .row {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap
        }

        .panel .btn {
            background: #232750;
            border: 1px solid var(--border);
            color: var(--text-2);
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer
        }

        .panel .btn.primary {
            background: var(--primary);
            color: white;
            border-color: transparent
        }

        .panel .btn.ghost {
            background: transparent
        }

        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
            font-size: 12px;
            color: #cfd6ff
        }

        th,
        td {
            border-top: 1px solid var(--border);
            padding: 6px 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis
        }

        th {
            color: #8ea2ff;
            text-align: left;
            background: #1a1f46
        }

        tr.sel {
            background: rgba(124, 92, 255, .15)
        }

        .kbd {
            display: inline-block;
            background: #10132b;
            border: 1px solid #2a2f4a;
            border-bottom-color: #1b1e35;
            color: #a8b1d8;
            border-radius: 6px;
            padding: 1px 6px;
            margin: 0 2px
        }

        /* æ–‡æœ¬ç¼–è¾‘è¾“å…¥æ¡†ï¼ˆåŒå‡»èŠ‚ç‚¹ï¼‰ */
        #editBox {
            position: absolute;
            z-index: 10;
            display: none;
            padding: 6px 8px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: #0f1226;
            color: var(--text);
            box-shadow: 0 8px 28px rgba(0, 0, 0, .35)
        }

        #editInput {
            width: 260px;
            max-width: 320px;
            background: transparent;
            color: inherit;
            border: none;
            outline: none
        }
    </style>
</head>

<body>
    <div class="app">
        <div class="canvas-wrap" id="canvasWrap">
            <canvas id="c"></canvas>
            <div class="toolbar">
                <button class="btn primary" id="btnAdd">ï¼‹ æ–°å»ºèŠ‚ç‚¹</button>
                <button class="btn" id="btnConnect">è¿æ¥æ¨¡å¼ï¼šå…³é—­</button>
                <button class="btn" id="btnResetView">é‡ç½®è§†å›¾</button>
                <button class="btn" id="btnExport">å¯¼å‡ºJSON</button>
                <button class="btn" id="btnImport">å¯¼å…¥JSON</button>
                <button class="btn danger" id="btnDelete">åˆ é™¤æ‰€é€‰</button>
            </div>
            <div class="hint">
                <div>ğŸ–±ï¸ <span class="kbd">æ»šè½®</span> ç¼©æ”¾ï¼Œ<span class="kbd">Space</span> æˆ– <span class="kbd">ä¸­é”®</span>
                    æ‹–åŠ¨ç”»å¸ƒ</div>
                <div>ğŸ–±ï¸ <span class="kbd">åŒå‡»</span> èŠ‚ç‚¹ç¼–è¾‘æ–‡æœ¬ï¼›ç‚¹å‡»è¾¹/èŠ‚ç‚¹å¯é€‰ä¸­ï¼Œ<span class="kbd">Delete</span> åˆ é™¤</div>
                <div>ğŸ§© è¿æ¥æ¨¡å¼ï¼šç‚¹å‡»èŠ‚ç‚¹ä½œä¸ºèµ·ç‚¹ â†’ å†ç‚¹ç›®æ ‡èŠ‚ç‚¹</div>
            </div>
            <!-- åŒå‡»èŠ‚ç‚¹æ—¶çš„æ–‡æœ¬ç¼–è¾‘æ¡† -->
            <div id="editBox"><input id="editInput" /></div>
        </div>

        <div class="panel">
            <h3>èŠ‚ç‚¹åˆ—è¡¨</h3>
            <div class="section" style="overflow:auto;min-height:120px;max-height:36%;">
                <table id="nodesTable">
                    <thead>
                        <tr>
                            <th style="width:60px">ID</th>
                            <th>æ–‡æœ¬</th>
                            <th style="width:70px">X</th>
                            <th style="width:70px">Y</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>

            <h3>è¿çº¿åˆ—è¡¨</h3>
            <div class="section" style="overflow:auto;min-height:120px;max-height:36%;">
                <table id="edgesTable">
                    <thead>
                        <tr>
                            <th style="width:60px">ID</th>
                            <th>ä»</th>
                            <th>åˆ°</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>

            <h3>å¯¼å…¥ / å¯¼å‡º</h3>
            <div class="section">
                <div class="row" style="margin-bottom:6px">
                    <button class="btn" id="btnCopy">å¤åˆ¶å¯¼å‡ºå†…å®¹</button>
                    <button class="btn" id="btnLoadTextarea">ä»æ–‡æœ¬åŠ è½½</button>
                    <button class="btn ghost" id="btnSample">ç¤ºä¾‹æ•°æ®</button>
                </div>
                <textarea id="ioArea" placeholder="ç‚¹å‡»ã€å¯¼å‡ºJSONã€æˆ–ç²˜è´´é…ç½®åç‚¹ã€ä»æ–‡æœ¬åŠ è½½ã€"></textarea>
            </div>
        </div>
    </div>

    <script>
        /* ====================== åŸºç¡€æ•°æ®ç»“æ„ ====================== */
        const state = {
            nodes: [],         // {id, x, y, w, h, text}
            edges: [],         // {id, from, to}
            selection: { nodeId: null, edgeId: null },
            view: { scale: 1, offsetX: 0, offsetY: 0 }, // ç”»å¸ƒè§†å›¾
            nextNodeId: 1,
            nextEdgeId: 1,
            connectMode: false,
            connectFrom: null,  // èŠ‚ç‚¹id
        };

        const DEFAULT_NODE = { w: 160, h: 60 };
        const COLORS = {
            nodeFill: '#212755',
            nodeStroke: '#4753a9',
            nodeText: '#e6ebff',
            nodeSel: '#7c5cff',
            grid: 'rgba(255,255,255,0.04)',
            edge: '#8aa4ff',
            edgeSel: '#ffb86b',
            edgeTemp: '#4fd1c5'
        };

        /* ====================== ç”»å¸ƒ & åæ ‡æ¢ç®— ====================== */
        const wrap = document.getElementById('canvasWrap');
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const dpr = Math.max(1, window.devicePixelRatio || 1);
            const w = wrap.clientWidth, h = wrap.clientHeight;
            canvas.width = Math.floor(w * dpr);
            canvas.height = Math.floor(h * dpr);
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // å…ˆç¼©æ”¾åˆ° CSS åƒç´ 
            draw();
        }
        window.addEventListener('resize', resizeCanvas);

        /** ç”»å¸ƒ -> ä¸–ç•Œåæ ‡ */
        function screenToWorld(x, y) {
            const { scale, offsetX, offsetY } = state.view;
            return {
                x: (x - offsetX) / scale,
                y: (y - offsetY) / scale
            };
        }
        /** ä¸–ç•Œ -> ç”»å¸ƒåæ ‡ */
        function worldToScreen(x, y) {
            const { scale, offsetX, offsetY } = state.view;
            return {
                x: x * scale + offsetX,
                y: y * scale + offsetY
            };
        }

        /* ====================== ç»˜åˆ¶ ====================== */
        function drawGrid() {
            const { scale, offsetX, offsetY } = state.view;
            const step = 32 * scale;
            const w = canvas.clientWidth, h = canvas.clientHeight;
            ctx.save();
            ctx.fillStyle = COLORS.grid;
            // å¯¹é½åç§»
            const startX = (-offsetX % step), startY = (-offsetY % step);
            for (let x = startX; x < w; x += step) {
                ctx.fillRect(x, 0, 1, h);
            }
            for (let y = startY; y < h; y += step) {
                ctx.fillRect(0, y, w, 1);
            }
            ctx.restore();
        }

        function drawNode(n, selected = false) {
            const { x, y, w, h, text } = n;
            const { scale } = state.view;
            const r = 10;
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0); // ä»¥å±å¹•åƒç´ ç”»é˜´å½±(æ›´æŸ”å’Œ)
            const p = worldToScreen(x, y);
            ctx.translate(p.x, p.y);

            // é˜´å½±
            ctx.shadowColor = 'rgba(0,0,0,0.35)';
            ctx.shadowBlur = 12; ctx.shadowOffsetY = 4;

            // å¤–æ¡†
            ctx.beginPath();
            roundRect(ctx, 0, 0, w * scale, h * scale, r * scale);
            ctx.fillStyle = COLORS.nodeFill;
            ctx.fill();
            ctx.lineWidth = selected ? 3 : 1.5;
            ctx.strokeStyle = selected ? COLORS.nodeSel : COLORS.nodeStroke;
            ctx.stroke();

            // æ–‡æœ¬
            ctx.shadowColor = 'transparent';
            ctx.fillStyle = COLORS.nodeText;
            ctx.font = `${Math.floor(14 * scale)}px ui-sans-serif,system-ui`;
            ctx.textBaseline = 'middle';
            ctx.fillText(text || 'æœªå‘½åèŠ‚ç‚¹', 12 * scale, (h * scale) / 2);
            ctx.restore();
        }

        function drawEdge(e, selected = false) {
            const from = getNodeById(e.from), to = getNodeById(e.to);
            if (!from || !to) return;

            const a = getRectAnchorPoint(from, to); // èµ·ç‚¹åœ¨æºçŸ©å½¢è¾¹ç•Œ
            const b = getRectAnchorPoint(to, from); // ç»ˆç‚¹åœ¨ç›®çš„çŸ©å½¢è¾¹ç•Œ
            const A = worldToScreen(a.x, a.y);
            const B = worldToScreen(b.x, b.y);

            const color = selected ? COLORS.edgeSel : COLORS.edge;
            drawArrow(A.x, A.y, B.x, B.y, color);
        }

        function drawTempEdge(fromNode, mouseWorld) {
            const a = getRectAnchorPoint(fromNode, { x: mouseWorld.x, y: mouseWorld.y, w: 0, h: 0 });
            const A = worldToScreen(a.x, a.y);
            const B = worldToScreen(mouseWorld.x, mouseWorld.y);
            drawArrow(A.x, A.y, B.x, B.y, COLORS.edgeTemp, 1.5, true);
        }

        function draw() {
            // æ¸…å±
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

            drawGrid();

            // ç”»è¾¹
            for (const e of state.edges) {
                drawEdge(e, state.selection.edgeId === e.id);
            }

            // ç”»èŠ‚ç‚¹
            for (const n of state.nodes) {
                drawNode(n, state.selection.nodeId === n.id);
            }

            // è¿æ¥æ¨¡å¼ä¸‹çš„ä¸´æ—¶çº¿
            if (state.connectMode && state.connectFrom && hover.pos) {
                const from = getNodeById(state.connectFrom);
                drawTempEdge(from, hover.worldPos);
            }
        }

        /* ========= è¾…åŠ©ç»˜å›¾å‡½æ•° ========= */
        function roundRect(ctx, x, y, w, h, r) {
            ctx.moveTo(x + r, y);
            ctx.beginPath();
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
        }

        // ç®­å¤´
        function drawArrow(x1, y1, x2, y2, color, width = 2, dashed = false) {
            const head = 10; // åƒç´ 
            ctx.save();
            ctx.strokeStyle = color; ctx.fillStyle = color;
            ctx.lineWidth = width;
            if (dashed) ctx.setLineDash([8, 6]);
            ctx.beginPath();
            ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
            // ç®­å¤´å¤´éƒ¨
            const ang = Math.atan2(y2 - y1, x2 - x1);
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - head * Math.cos(ang - Math.PI / 6), y2 - head * Math.sin(ang - Math.PI / 6));
            ctx.lineTo(x2 - head * Math.cos(ang + Math.PI / 6), y2 - head * Math.sin(ang + Math.PI / 6));
            ctx.closePath(); ctx.fill();
            ctx.restore();
        }

        // è®¡ç®—çŸ©å½¢æŒ‡å‘å¦ä¸€ä¸ªç‚¹æ—¶ï¼Œè¿çº¿åœ¨çŸ©å½¢è¾¹ä¸Šçš„äº¤ç‚¹
        function getRectAnchorPoint(rect, towards) {
            const cx = rect.x + rect.w / 2, cy = rect.y + rect.h / 2;
            const dx = towards.x - cx, dy = towards.y - cy;
            if (dx === 0 && dy === 0) return { x: cx, y: cy };
            const m = dy / dx;
            // ä»¥ä¸­å¿ƒå°„çº¿ä¸çŸ©å½¢è¾¹ç›¸äº¤
            let x = 0, y = 0;
            const hw = rect.w / 2, hh = rect.h / 2;
            if (Math.abs(m) < hh / hw) {
                // æ’å·¦å³è¾¹
                x = dx > 0 ? cx + hw : cx - hw;
                y = cy + m * (x - cx);
            } else {
                // æ’ä¸Šä¸‹è¾¹
                y = dy > 0 ? cy + hh : cy - hh;
                x = cx + (y - cy) / m;
            }
            return { x, y };
        }

        /* ====================== å‘½ä¸­æ£€æµ‹ ====================== */
        function getNodeAt(worldX, worldY) {
            for (let i = state.nodes.length - 1; i >= 0; i--) { // ä»ä¸Šå±‚å¾€ä¸‹å‘½ä¸­
                const n = state.nodes[i];
                if (worldX >= n.x && worldX <= n.x + n.w && worldY >= n.y && worldY <= n.y + n.h) {
                    return n;
                }
            }
            return null;
        }

        function getEdgeAt(worldX, worldY) {
            const px = worldToScreen(worldX, worldY); // ç”¨å±å¹•åƒç´ é˜ˆå€¼æ›´ç¨³å®š
            const TH = 6; // åƒç´ å®¹å·®
            for (let i = state.edges.length - 1; i >= 0; i--) {
                const e = state.edges[i];
                const a = getRectAnchorPoint(getNodeById(e.from), getNodeById(e.to));
                const b = getRectAnchorPoint(getNodeById(e.to), getNodeById(e.from));
                const A = worldToScreen(a.x, a.y);
                const B = worldToScreen(b.x, b.y);
                const d = pointToSegDist(px.x, px.y, A.x, A.y, B.x, B.y);
                if (d <= TH) return e;
            }
            return null;
        }

        function pointToSegDist(px, py, x1, y1, x2, y2) {
            const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
            const dot = A * C + B * D;
            const len_sq = C * C + D * D;
            let t = dot / len_sq;
            t = Math.max(0, Math.min(1, t));
            const xx = x1 + t * C, yy = y1 + t * D;
            const dx = px - xx, dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        /* ====================== äº¤äº’ï¼šæ·»åŠ  / é€‰æ‹© / æ‹–æ‹½ / è¿æ¥ ====================== */
        function addNodeAt(worldX, worldY, label = 'æ–°èŠ‚ç‚¹') {
            const node = {
                id: state.nextNodeId++,
                x: worldX, y: worldY,
                w: DEFAULT_NODE.w, h: DEFAULT_NODE.h,
                text: label
            };
            state.nodes.push(node);
            selectNode(node.id);
            syncTables();
            draw();
        }

        function getNodeById(id) { return state.nodes.find(n => n.id === id); }
        function getEdgeById(id) { return state.edges.find(e => e.id === id); }

        function selectNode(id) {
            state.selection.nodeId = id;
            state.selection.edgeId = null;
            highlightTables();
        }
        function selectEdge(id) {
            state.selection.edgeId = id;
            state.selection.nodeId = null;
            highlightTables();
        }

        function removeSelection() {
            if (state.selection.nodeId != null) {
                // åˆ é™¤è¯¥èŠ‚ç‚¹ & ç›¸å…³è¿çº¿
                const id = state.selection.nodeId;
                state.nodes = state.nodes.filter(n => n.id !== id);
                state.edges = state.edges.filter(e => e.from !== id && e.to !== id);
            } else if (state.selection.edgeId != null) {
                const id = state.selection.edgeId;
                state.edges = state.edges.filter(e => e.id !== id);
            }
            state.selection.nodeId = state.selection.edgeId = null;
            syncTables();
            draw();
        }

        /* æ‹–æ‹½ä¸å¹³ç§» */
        const drag = { active: false, nodeId: null, start: { x: 0, y: 0 }, nodeStart: { x: 0, y: 0 }, panning: false };
        const hover = { pos: null, worldPos: { x: 0, y: 0 } };

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
            const world = screenToWorld(sx, sy);
            hover.pos = { x: sx, y: sy }; hover.worldPos = world;

            const midButton = e.button === 1;
            const spacePan = keyState.space;
            if (midButton || spacePan) {
                drag.active = true; drag.panning = true;
                drag.start = { x: e.clientX, y: e.clientY };
                return;
            }

            const node = getNodeAt(world.x, world.y);
            if (state.connectMode) {
                // è¿æ¥æ¨¡å¼ï¼šç‚¹å‡»èŠ‚ç‚¹é€‰èµ·ç‚¹ or ç»ˆç‚¹
                if (!state.connectFrom && node) {
                    state.connectFrom = node.id;
                    draw();
                } else if (state.connectFrom && node && node.id !== state.connectFrom) {
                    // åˆ›å»ºè¾¹
                    state.edges.push({ id: state.nextEdgeId++, from: state.connectFrom, to: node.id });
                    state.connectFrom = null;
                    syncTables(); draw();
                }
                return;
            }

            if (node) {
                selectNode(node.id);
                // å¼€å¯æ‹–æ‹½
                drag.active = true; drag.nodeId = node.id; drag.panning = false;
                drag.start = { x: sx, y: sy };
                drag.nodeStart = { x: node.x, y: node.y };
            } else {
                const edge = getEdgeAt(world.x, world.y);
                if (edge) {
                    selectEdge(edge.id);
                } else {
                    // æœªç‚¹åˆ°å…ƒç´ ï¼šæ¸…ç©ºé€‰æ‹©
                    state.selection.nodeId = state.selection.edgeId = null;
                    highlightTables(); draw();
                }
            }
        });

        window.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
            hover.pos = { x: sx, y: sy };
            hover.worldPos = screenToWorld(sx, sy);

            if (drag.active) {
                if (drag.panning) {
                    const dx = e.clientX - drag.start.x;
                    const dy = e.clientY - drag.start.y;
                    drag.start = { x: e.clientX, y: e.clientY };
                    state.view.offsetX += dx;
                    state.view.offsetY += dy;
                    draw();
                    return;
                }
                const node = getNodeById(drag.nodeId);
                if (node) {
                    const dx = (sx - drag.start.x) / state.view.scale;
                    const dy = (sy - drag.start.y) / state.view.scale;
                    node.x = drag.nodeStart.x + dx;
                    node.y = drag.nodeStart.y + dy;
                    syncTables();
                    draw();
                }
            } else if (state.connectMode && state.connectFrom) {
                draw(); // é‡ç»˜ä¸´æ—¶è¿çº¿
            }
        });

        window.addEventListener('mouseup', () => {
            drag.active = false; drag.nodeId = null; drag.panning = false;
        });

        /* åŒå‡»ç¼–è¾‘æ–‡æœ¬ï¼ˆä½¿ç”¨æµ®å±‚è¾“å…¥æ¡†ï¼‰ */
        const editBox = document.getElementById('editBox');
        const editInput = document.getElementById('editInput');

        canvas.addEventListener('dblclick', (e) => {
            const { x, y } = getCanvasRelative(e);
            const world = screenToWorld(x, y);
            const n = getNodeAt(world.x, world.y);
            if (n) {
                // åœ¨èŠ‚ç‚¹ä¸Šç¼–è¾‘
                const p = worldToScreen(n.x + 12, n.y + n.h / 2);
                editBox.style.left = (p.x) + 'px';
                editBox.style.top = (p.y - 14) + 'px';
                editInput.value = n.text || '';
                editBox.style.display = 'block';
                editInput.focus();
                // ä¿å­˜
                const finish = () => {
                    n.text = editInput.value.trim() || 'æœªå‘½åèŠ‚ç‚¹';
                    editBox.style.display = 'none';
                    syncTables(); draw();
                    editInput.removeEventListener('keydown', onKey);
                    document.removeEventListener('click', onBlur, true);
                };
                const onKey = (ev) => {
                    if (ev.key === 'Enter') { finish(); }
                    if (ev.key === 'Escape') { editBox.style.display = 'none'; editInput.removeEventListener('keydown', onKey); document.removeEventListener('click', onBlur, true); }
                };
                const onBlur = (ev) => {
                    if (!editBox.contains(ev.target)) { finish(); }
                };
                editInput.addEventListener('keydown', onKey);
                setTimeout(() => document.addEventListener('click', onBlur, true), 0);
            } else {
                // åŒå‡»ç©ºç™½ï¼šä¹Ÿå¯ä»¥å¿«é€Ÿæ–°å¢èŠ‚ç‚¹
                addNodeAt(world.x - DEFAULT_NODE.w / 2, world.y - DEFAULT_NODE.h / 2, 'æ–°èŠ‚ç‚¹');
            }
        });

        /* ====================== ç¼©æ”¾ & è§†å›¾ ====================== */
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = -e.deltaY; // ä¸Šæ»šæ”¾å¤§
            const factor = Math.exp(delta * 0.0015);
            zoomAt(e.offsetX, e.offsetY, factor);
        }, { passive: false });

        function zoomAt(sx, sy, factor) {
            const { scale, offsetX, offsetY } = state.view;
            const worldBefore = screenToWorld(sx, sy);
            const newScale = Math.min(3, Math.max(0.25, scale * factor));
            state.view.scale = newScale;
            // è°ƒæ•´åç§»ï¼Œä¿æŒå…‰æ ‡æ‰€æŒ‡ä¸–ç•Œåæ ‡ä¸åŠ¨
            const worldAfter = worldBefore;
            state.view.offsetX = sx - worldAfter.x * newScale;
            state.view.offsetY = sy - worldAfter.y * newScale;
            draw();
        }

        function resetView() {
            state.view = { scale: 1, offsetX: 20, offsetY: 20 };
            draw();
        }

        /* ====================== é”®ç›˜ ====================== */
        const keyState = { space: false };
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') { keyState.space = true; }
            if (e.key === 'Delete') { removeSelection(); }
        });
        window.addEventListener('keyup', (e) => {
            if (e.code === 'Space') { keyState.space = false; }
        });

        /* ====================== å¯¼å…¥ / å¯¼å‡º ====================== */
        function exportJSON() {
            const data = {
                nodes: state.nodes.map(n => ({ id: n.id, x: n.x, y: n.y, w: n.w, h: n.h, text: n.text })),
                edges: state.edges.map(e => ({ id: e.id, from: e.from, to: e.to })),
                view: state.view,
                nextNodeId: state.nextNodeId,
                nextEdgeId: state.nextEdgeId
            };
            return JSON.stringify(data, null, 2);
        }
        function importJSON(text) {
            const data = JSON.parse(text);
            if (!data || !Array.isArray(data.nodes) || !Array.isArray(data.edges)) throw new Error('æ— æ•ˆçš„é…ç½®');
            state.nodes = data.nodes;
            state.edges = data.edges;
            state.view = data.view || { scale: 1, offsetX: 0, offsetY: 0 };
            state.nextNodeId = data.nextNodeId || (Math.max(0, ...state.nodes.map(n => n.id)) + 1);
            state.nextEdgeId = data.nextEdgeId || (Math.max(0, ...state.edges.map(e => e.id)) + 1);
            state.selection.nodeId = state.selection.edgeId = null;
            syncTables(); draw();
        }

        /* ====================== UI & è¡¨æ ¼ ====================== */
        const nodesTable = document.querySelector('#nodesTable tbody');
        const edgesTable = document.querySelector('#edgesTable tbody');
        const ioArea = document.getElementById('ioArea');

        function syncTables() {
            // èŠ‚ç‚¹
            nodesTable.innerHTML = '';
            for (const n of state.nodes) {
                const tr = document.createElement('tr');
                tr.dataset.id = n.id;
                tr.innerHTML = `<td>${n.id}</td><td>${escapeHtml(n.text)}</td><td>${n.x.toFixed(1)}</td><td>${n.y.toFixed(1)}</td>`;
                tr.addEventListener('click', () => { selectNode(n.id); draw(); });
                nodesTable.appendChild(tr);
            }
            // è¾¹
            edgesTable.innerHTML = '';
            for (const e of state.edges) {
                const tr = document.createElement('tr');
                tr.dataset.id = e.id;
                tr.innerHTML = `<td>${e.id}</td><td>${e.from}</td><td>${e.to}</td>`;
                tr.addEventListener('click', () => { selectEdge(e.id); draw(); });
                edgesTable.appendChild(tr);
            }
            highlightTables();
        }

        function highlightTables() {
            for (const tr of nodesTable.querySelectorAll('tr')) {
                tr.classList.toggle('sel', Number(tr.dataset.id) === state.selection.nodeId);
            }
            for (const tr of edgesTable.querySelectorAll('tr')) {
                tr.classList.toggle('sel', Number(tr.dataset.id) === state.selection.edgeId);
            }
        }

        function escapeHtml(s) { return String(s).replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m])); }

        /* ====================== é¡¶éƒ¨å·¥å…·æ¡æŒ‰é’® ====================== */
        document.getElementById('btnAdd').onclick = () => {
            const wp = screenToWorld(canvas.clientWidth / 2, canvas.clientHeight / 2);
            addNodeAt(wp.x - DEFAULT_NODE.w / 2, wp.y - DEFAULT_NODE.h / 2, 'æ–°èŠ‚ç‚¹');
        };

        document.getElementById('btnConnect').onclick = () => {
            state.connectMode = !state.connectMode;
            state.connectFrom = null;
            document.getElementById('btnConnect').textContent = 'è¿æ¥æ¨¡å¼ï¼š' + (state.connectMode ? 'å¼€å¯' : 'å…³é—­');
            draw();
        };

        document.getElementById('btnResetView').onclick = resetView;

        document.getElementById('btnExport').onclick = () => {
            ioArea.value = exportJSON();
        };

        document.getElementById('btnImport').onclick = () => {
            try {
                importJSON(ioArea.value.trim());
                alert('å¯¼å…¥æˆåŠŸ');
            } catch (err) {
                alert('å¯¼å…¥å¤±è´¥ï¼š' + err.message);
            }
        };

        document.getElementById('btnDelete').onclick = removeSelection;

        document.getElementById('btnCopy').onclick = async () => {
            const text = ioArea.value || exportJSON();
            try {
                await navigator.clipboard.writeText(text);
                alert('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
            } catch { alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©æ–‡æœ¬ã€‚'); }
        };

        document.getElementById('btnLoadTextarea').onclick = () => {
            try {
                importJSON(ioArea.value);
                alert('å·²ä»æ–‡æœ¬åŠ è½½');
            } catch (e) { alert('JSON æ— æ•ˆï¼š' + e.message); }
        };

        document.getElementById('btnSample').onclick = () => {
            const demo = {
                nodes: [
                    { id: 1, x: 80, y: 100, w: 160, h: 60, text: 'æ•°æ®æº' },
                    { id: 2, x: 340, y: 100, w: 180, h: 60, text: 'æ¸…æ´—ä¸æ ¡éªŒ' },
                    { id: 3, x: 640, y: 100, w: 180, h: 60, text: 'å…¥åº“å†™å…¥' },
                    { id: 4, x: 340, y: 220, w: 240, h: 60, text: 'å¼‚å¸¸å¤„ç†/å‘Šè­¦' },
                ],
                edges: [
                    { id: 1, from: 1, to: 2 },
                    { id: 2, from: 2, to: 3 },
                    { id: 3, from: 2, to: 4 }
                ],
                view: { scale: 1, offsetX: 20, offsetY: 40 },
                nextNodeId: 5, nextEdgeId: 4
            };
            ioArea.value = JSON.stringify(demo, null, 2);
        };

        /* ====================== å·¥å…·å‡½æ•° ====================== */
        function getCanvasRelative(evt) {
            const rect = canvas.getBoundingClientRect();
            return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
        }

        /* ====================== åˆå§‹åŒ– & è‡ªæ£€ ====================== */
        function selfTest() {
            // åŸºæœ¬è‡ªæ£€ï¼šå¢åˆ æ”¹æŸ¥ & å¯¼å…¥å¯¼å‡º & è§†å›¾
            state.nodes = [];
            state.edges = [];
            state.nextNodeId = 1;
            state.nextEdgeId = 1;
            resetView();
            addNodeAt(60, 60, 'è¾“å…¥');
            addNodeAt(320, 60, 'å¤„ç†');
            addNodeAt(580, 60, 'è¾“å‡º');
            state.edges.push({ id: state.nextEdgeId++, from: 1, to: 2 });
            state.edges.push({ id: state.nextEdgeId++, from: 2, to: 3 });
            syncTables();
            // å¯¼å‡º & å¯¼å…¥å›æ”¾æµ‹è¯•
            const dump = exportJSON();
            importJSON(dump);
        }
        resizeCanvas();
        selfTest();
    </script>
</body>

</html>