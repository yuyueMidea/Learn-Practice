## react高频问题及解答方案

虚拟dom工作原理与diff算法优化，解释虚拟dom如何提升性能？Diff算法的比较规则是什么？

回答：
- 虚拟dom是轻量级JS对象，通过对比新旧虚拟DOM树（Diffing），仅更新差异部分到真实dom，减少重绘开销；
- Diff算法采用分层比较，同层节点从左到右遍历，类型相同则更新属性，列表元素依赖key来标识移动、复用（避免索引作为key）；

Hooks原理与限制，为何Hooks不能在条件语句中使用？useState的函数更新与直接传值有啥区别？

回答：
- Hooks依赖调用顺序维护状态链表，条件语句会破坏顺序一致性；
- setCount(count + 1)直接传值在异步更新中可能使用旧值；setCount(prev => prev + 1)函数更新确保基于最新状态；

受控组件 VS 非受控组件；何时选择受控组件？如何用Ref访问表单数据？

回答：
- 受控组件：表单值由react状态管理（value + onChange），适合实时验证、提交；
- 非受控组件：用Ref直接获取dom值（如inputRef.current.value），适合文件上传等低频操作；


**Hooks深度机制**

useEffect依赖数组与清理机制，依赖项为空数组`[]` 与未传依赖的区别？如何避免内存泄漏？

解答：
- []：仅执行一次（类似componentDidMount）；无依赖项：每次渲染后执行；[dep]：依赖变化时执行；
- 清理函数：返回的函数在组件卸载或依赖更新前执行，（如取消订阅、清除定时器）；

useMemo与useCallback性能优化；何时使用useMemo？useCallback解决什么问题?

解答：
- useMemo：缓存计算结果，仅在依赖变化时重新计算，避免重复执行开销大的函数，避免重复执行复杂运算（如过滤大型列表）；
- useCallback：缓存函数引用，避免子组件因为回调函数重新生成导致无效渲染，（需要配合React.memo）；useCallback用于缓存某个函数的定义，只有依赖变化时才会重新生成函数，可以避免函数在每次渲染时都创建新的引用；
- 错误用法：过度使用反而会增加内存开销；仅在高开销的操作或者依赖变动频繁时使用。
