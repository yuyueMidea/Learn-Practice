**一、软件工程（Software Engineering）**
| 中文     | 英文                          | 解释                 |
| ------ | --------------------------- | ------------------ |
| 软件工程   | Software Engineering        | 系统化的软件开发方法论        |
| 需求分析   | Requirement Analysis        | 收集并分析系统需求的过程       |
| 系统设计   | System Design               | 对系统进行整体和详细设计       |
| 高内聚    | High Cohesion               | 模块内部功能相关性强         |
| 低耦合    | Low Coupling                | 模块间依赖性弱            |
| 版本控制   | Version Control             | 管理代码版本（Git 等）      |
| 配置管理   | Configuration Management    | 管理软件的配置项和变更        |
| 架构设计   | Architecture Design         | 系统的整体结构设计          |
| 可维护性   | Maintainability             | 软件容易修改和扩展的能力       |
| 可扩展性   | Scalability                 | 系统在负载增加时保持性能的能力    |
| 可移植性   | Portability                 | 软件在不同平台运行的能力       |
| 持续集成   | Continuous Integration (CI) | 自动化构建和测试           |
| 持续交付   | Continuous Delivery         | 自动化部署到测试或预发布环境     |
| 持续部署   | Continuous Deployment       | 自动化部署到生产环境         |
| DevOps | DevOps                      | 开发与运维协作的文化和流程      |
| 敏捷开发   | Agile Development           | 强调快速迭代和用户反馈的软件开发模式 |
| Scrum  | Scrum                       | 敏捷开发的一种框架          |
| 看板     | Kanban                      | 可视化任务流的管理方法        |
| 代码审查   | Code Review                 | 对代码进行检查和改进的过程      |

**二、设计模式（Design Patterns）**
| 中文      | 英文                              | 解释              |
| ------- | ------------------------------- | --------------- |
| 设计模式    | Design Pattern                  | 可复用的面向对象解决方案    |
| 单例模式    | Singleton Pattern               | 保证类只有一个实例       |
| 工厂模式    | Factory Pattern                 | 通过工厂方法创建对象      |
| 抽象工厂模式  | Abstract Factory Pattern        | 提供一组相关对象的创建接口   |
| 策略模式    | Strategy Pattern                | 定义一组算法并封装       |
| 观察者模式   | Observer Pattern                | 一对多的依赖关系，事件触发通知 |
| 发布-订阅模式 | Publish-Subscribe Pattern       | 类似观察者，但通过消息代理   |
| 装饰器模式   | Decorator Pattern               | 动态添加功能而不修改类     |
| 代理模式    | Proxy Pattern                   | 控制对对象的访问        |
| 适配器模式   | Adapter Pattern                 | 将接口转换成兼容的形式     |
| 外观模式    | Facade Pattern                  | 提供统一接口，简化复杂系统   |
| 建造者模式   | Builder Pattern                 | 分步骤构建复杂对象       |
| 原型模式    | Prototype Pattern               | 通过克隆创建对象        |
| 模板方法模式  | Template Method Pattern         | 定义算法框架，子类实现细节   |
| 命令模式    | Command Pattern                 | 将请求封装为对象        |
| 责任链模式   | Chain of Responsibility Pattern | 让多个对象处理请求       |
| 备忘录模式   | Memento Pattern                 | 保存对象状态以便恢复      |
| 组合模式    | Composite Pattern               | 组合对象形成树形结构      |
| 享元模式    | Flyweight Pattern               | 共享对象减少内存消耗      |

**三、软件测试（Software Testing）**
| 中文     | 英文                  | 解释               |
| ------ | ------------------- | ---------------- |
| 单元测试   | Unit Testing        | 测试最小功能单元（函数、方法）  |
| 集成测试   | Integration Testing | 测试模块之间的接口        |
| 系统测试   | System Testing      | 测试整个系统的功能和性能     |
| 验收测试   | Acceptance Testing  | 验证系统是否满足用户需求     |
| 自动化测试  | Automated Testing   | 使用工具脚本自动执行测试     |
| 黑盒测试   | Black-Box Testing   | 不考虑内部逻辑，测试输入输出   |
| 白盒测试   | White-Box Testing   | 测试代码逻辑和结构        |
| 冒烟测试   | Smoke Testing       | 快速检查主要功能是否可用     |
| 回归测试   | Regression Testing  | 验证修改是否引入新问题      |
| 压力测试   | Stress Testing      | 验证系统在极端条件下的表现    |
| 性能测试   | Performance Testing | 测试系统在负载下的响应和稳定性  |
| 安全测试   | Security Testing    | 检查系统的安全性         |
| Mock对象 | Mock Object         | 测试中模拟依赖对象        |
| 测试用例   | Test Case           | 描述测试输入、执行条件和预期结果 |
| 测试覆盖率  | Test Coverage       | 测试代码被覆盖的比例       |
| CI测试   | CI Testing          | 集成到持续集成流水线的测试    |
