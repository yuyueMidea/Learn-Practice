## 前端事件循环、微任务与宏任务全面解析

JavaScript 的事件循环（Event Loop）是理解异步编程的核心机制，它决定了代码的执行顺序，下面介绍事件循环的原理 以及宏任务和微任务的区别：

一、事件循环基本模型
```
┌───────────────────────┐
│        Call Stack     │
└───────────┬───────────┘
            │
┌───────────▼───────────┐
│        Event Loop     │
└───────────┬───────────┘
            │
┌───────────▼───────────┐
│    Task Queue        │
│   (Macrotask Queue)  │
└───────────┬───────────┘
            │
┌───────────▼───────────┐
│    Microtask Queue    │
└───────────────────────┘
```
二、执行顺序规则：
1. 同步代码：首先执行调用栈中所有的同步任务；
2. 微任务：当调用栈清空后，执行所有微任务队列中的任务；
3. 宏任务：每次从宏任务队列中取出一个任务执行；
4. 重复：检查微任务队列并执行，然后取出下一个宏任务；
5. 重要原则是：每次执行一个宏任务，都会清空整个微任务队列；

**微任务与宏任务分类**
- 微任务（Microtasks）： Promise.then, Promise.catch, Promise.finally()；process.nextTick (Node.js 环境)
- 宏任务（Macrotasks/Tasks）：setTimeout / setInterval，setImmediate (Node.js 环境)，requestAnimationFrame (浏览器环境)、I/O操作、UI渲染、事件回调（click、scroll等）


**常见问题**
```
setTimeout(() => console.log(1), 0);
Promise.resolve().then(() => console.log(2));
console.log(3);

// 输出顺序：3 → 2 → 1
// 解释：
// 1. 同步代码先执行(3)
// 2. 然后执行微任务队列(2)
// 3. 最后执行宏任务队列(1)
```

**实际应用建议**
1. 性能优化：将高优先级任务放在微任务中；长任务分解为多个微任务；
2. 避免问题：不要嵌套太多微任务；宏任务适合处理不紧急的UI更新。




